#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerE,         sensorAnalog)
#pragma config(Sensor, dgtl1,  quadLeft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  DNJ,            sensorDigitalIn)
#pragma config(Sensor, dgtl4,  UPJ,            sensorDigitalIn)
#pragma config(Sensor, dgtl8,  quadRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl12, led,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           up,            tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           driveLeft1,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           left1,         tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port4,           left2,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           right1,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port7,           right2,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           intake2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           driveRight1,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port10,          intake,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify
#include "Functions.h"


void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	nMotorEncoder[left1] = 0;
	nMotorEncoder[right1] = 0;
	nMotorEncoder[driveLeft1] = 0;
	nMotorEncoder[driveRight1] = 0;
	SensorValue[quadLeft] = 0;
	SensorValue[quadRight] = 0;
	clearTimer(T1);
	clearTimer(T2);
	bStopTasksBetweenModes = true;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	autonSelector();
}

task usercontrol()
{
	requestedShooterSpeed = 460;
	int intakeControl;
	int driveLeftControl;
	int driveRightControl;
	int upControl;
	int startShooterControl;

	int incUpCtrl;
	int incDownCtrl;
	int incUpCtrlSmall;
	int incDownCtrlSmall;
	int divideByZero = 0;

	while (true)	{
		if(updatePID == 0) {
			bPlaySounds = false;
		}
		intakeControl = vexRT[Ch3];
		driveLeftControl = vexRT[Ch3Xmtr2] * driveTrainSpeedControl;
		driveRightControl = vexRT[Ch2Xmtr2] * driveTrainSpeedControl;
		upControl = vexRT[Ch2];
		startShooterControl = vexRT[Btn8D];

		incUpCtrl = vexRT[Btn5U];
		incDownCtrl = vexRT[Btn5D];

		incUpCtrlSmall = vexRT[Btn6U];
		incDownCtrlSmall = vexRT[Btn6D];

		if((incUpCtrl == 1) && (requestedShooterSpeed<PID_VEL_MAX)&&(incUpLastPress == false))
		{
			incUpLastPress = true;
			requestedShooterSpeed += incValue;
			wait1Msec(200);
		}
		else if(incUpCtrl == 0)
		{
			incUpLastPress = false;
		}
		if((incDownCtrl == 1) && (requestedShooterSpeed>0)&&(incDownLastPress == false))
		{
			incDownLastPress = true;
			requestedShooterSpeed -= incValue;
			wait1Msec(200);
		}
		else if(incDownCtrl == 0)
		{
			incDownLastPress = false;
		}

		if((incUpCtrlSmall == 1) && (requestedShooterSpeed<PID_VEL_MAX)&&(incUpLastPressSmall == false))
		{
			incUpLastPressSmall = true;
			requestedShooterSpeed += incValueSmall;
			wait1Msec(200);
		}
		else if(incUpCtrlSmall == 0)
		{
			incUpLastPressSmall = false;
		}

		if((incDownCtrlSmall == 1) && (requestedShooterSpeed>0)&&(incDownLastPressSmall == false))
		{
			incDownLastPressSmall = true;
			requestedShooterSpeed -= incValueSmall;
			wait1Msec(200);
		}
		else if(incDownCtrlSmall == 0)
		{
			incDownLastPressSmall = false;
		}

		if(requestedShooterSpeed > PID_VEL_MAX)
		{
			requestedShooterSpeed = PID_VEL_MAX;
		}
		if(requestedShooterSpeed < 0)
		{
			requestedShooterSpeed = 0;
		}

		if(vexRT[Btn7U] == 1)
		{
			requestedShooterSpeed = 460;
			pid_Kp_selected = 0.0235;
			pid_Ki_selected = 0.0;
			pid_Kd_selected = 0.765;

			pid_Kp_selectedR = 0.025;
			pid_Ki_selectedR = 0.0;
			pid_Kd_selectedR = 0.75;
		}

		if(vexRT[Btn7D] == 1)
		{
			requestedShooterSpeed = 380;
			pid_Kp_selected = 0.023;
			pid_Ki_selected = 0.0;
			pid_Kd_selected = 0.758;

			pid_Kp_selectedR = 0.023;
			pid_Ki_selectedR = 0.0;
			pid_Kd_selectedR = 0.758;
		}
		if(vexRT[Btn8R] == 1)
		{
			requestedShooterSpeed=380;
			pid_Kp_selected = 0.023;
			pid_Ki_selected = 0.0;
			pid_Kd_selected = 0.999;

			pid_Kp_selectedR = 0.023;
			pid_Ki_selectedR = 0.0;
			pid_Kd_selectedR = 0.999;
		}
		if(vexRT[Btn7L] == 1 && divideByZero == 0)
		{
			divideByZero = 1;
			flyStartup = 1;
			pid_Kp = 0.05;
			pid_Ki = 0.0;
			pid_Kd = 0.4;

			pid_Kp_right = 0.05;
			pid_Ki_right = 0.0;
			pid_Kd_right = 0.41;
			flyVelocityL = 0;
			flyVelocityR = 0;
			updatePID = 1;
			bPlaySounds = true;
			startTask(pidController);

		}

		if(updatePID == 1)

		{
			motor[left1] = pidDriveL;
			motor[left2] = pidDriveL;
			motor[right1] = pidDriveR;
			motor[right2] = pidDriveR;
		}

		if(vexRT[Btn7DXmtr2] == 1)
		{
			driveTrainSpeedControl = 0.3;
		}
		else if(vexRT[Btn7UXmtr2] == 1)
		{
			driveTrainSpeedControl = 1;
		}
		if(abs(intakeControl) > deadzone)
		{
			motor[intake] = intakeControl;
			motor[intake2] = intakeControl;
		}
		else
		{
			motor[intake] = 0;
			motor[intake2] = 0;
		}
		if(abs(driveLeftControl) > deadzone)
		{
			motor[driveLeft1] = driveLeftControl;
		}
		else
		{
			motor[driveLeft1] = 0;
		}
		if(abs(driveRightControl) > deadzone)
		{
			motor[driveRight1] = driveRightControl;
		}
		else
		{
			motor[driveRight1] = 0;
		}
		if(abs(upControl) > deadzone)
		{
			motor[up] = upControl;
		}
		else
		{
			motor[up] = 0;
		}
		if(startShooterControl == 1)
		{
			startup();
			divideByZero = 0;
		}
		else if(vexRT[Btn8L] == 1)
		{
			slowDown();
			divideByZero = 0;
		}

		SensorValue(led) = updatePID;

		// Displays Battery Levels to VEX Remote Screen
		powerExpanderBatteryV = SensorValue[in1]/.28;
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDPos(0,0);
		displayNextLCDString("Cortex Bat:");
		displayNextLCDNumber(nAvgBatteryLevel);
		displayLCDPos(1,0);
		displayNextLCDString("PowerE Bat:");
		displayNextLCDNumber(powerExpanderBatteryV);
		//Graphing for PID tuning
		datalogDataGroupStart();
		datalogAddValue(0, flyVelocityL );
		datalogAddValue(1, flyVelocityR );
		datalogAddValue(2, pidDriveL);
		datalogAddValue(3, pidDriveR);
		datalogAddValue(4, timeSinceLastRun);
		datalogDataGroupEnd();
		wait1Msec(50);
	}
}
