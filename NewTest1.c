#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerE,         sensorAnalog)
#pragma config(Sensor, dgtl1,  ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           up,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           left1,         tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port3,           left2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           driveLeft1,    tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port6,           driveRight1,   tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port8,           right1,        tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port9,           right2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          up2,           tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)


#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#define PID_DRIVE_MAX 90
#define PID_DRIVE_MIN 0

#define PID_INTEGRAL_LIMIT 40
#define incValue 5
#define incValueSmall 1
#define SMLIB_TPR_393Turbo 261.333
#define SMLIB_TPR_393Speed 392.0
#define SMLIB_TPR_393Torque 627.2
#define SMLIB_TPR_393Quad 360.0

#define SMLIB_R_SYS             0.3
#define SMLIB_PWM_FREQ          1150
#define SMLIB_V_DIODE           0.75

// parameters for vex 393 motor
#define SMLIB_I_FREE_393        0.2
#define SMLIB_I_STALL_393       4.8
#define SMLIB_RPM_FREE_393      110
#define SMLIB_R_393             (7.2/SMLIB_I_STALL_393)
#define SMLIB_L_393             0.000650
#define SMLIB_Ke_393            (7.2*(1-SMLIB_I_FREE_393/SMLIB_I_STALL_393)/SMLIB_RPM_FREE_393)
#define SMLIB_I_SAFE393         0.90

typedef struct _motor_controller {
	tMotor          motor;                  ///< The motor port

	float           ticks_per_rev;          ///< IME ticks per rev
	tSensors        encoder_id;             ///< motor mush have an encoder

	// variables related to velocity measurement
	long            e_count;                ///< new encoder count
	long            e_count_last;           ///< previous encoder count
	long            e_timestamp;            ///< new encoder timestamp
	long            e_timestamp_last;       ///< last encoder timestamp
	long            v_current;              ///< last calculated velocity

	// variables used for current calculation
	float           i_free;                 ///< free current for motor
	float           i_stall;                ///< stall current for motor
	float           r_motor;                ///< resistance of motor
	float           l_motor;                ///< inductance of motor
	float           ke_motor;               ///< back emf constant
	float           rpm_free;               ///< free speed of motor with no load
	float           v_bemf_max;             ///< maximum back emf motor will generate
	float           current;                ///< instantaneous calculated current
	float           filtered_current;       ///< average current
	float           peak_current;           ///< peak current
} motor_controller;
int a = 35;
int b = 43;
int deadzone = 20;
float driveTrainSpeedControl = 1.0;
int sonarValue = 0;
float powerExpanderBatteryV = 2;

float flyVelocityL;
float flyVelocityR;

float targetSpeed;
float pidDriveL;
float pidDriveR;
int incUpLastPress = 0;
int incDownLastPress = 0;
int incUpLastPressSmall = 0;
int incDownLastPressSmall = 0;
int requestedShooterSpeed = 0;

int updatePID;

// Left motor
motor_controller  fwmL;
// Right motor
motor_controller  fwmR;

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
void slowDown()
{
			motor[left1] = a;
			motor[left2] = a;
			motor[right1] = a;
			motor[right2] = a;
			wait1Msec(500);
			motor[left1] = a-5;
			motor[left2] = a-5;
			motor[right1] = a-5;
			motor[right2] = a-5;
			wait1Msec(500);
			motor[left1] = a-10;
			motor[left2] = a-10;
			motor[right1] = a-10;
			motor[right2] = a-10;
			wait1Msec(500);
			motor[left1] = a-15;
			motor[left2] = a-15;
			motor[right1] = a-15;
			motor[right2] = a-15;
			wait1Msec(500);
			motor[left1] = a-20;
			motor[left2] = a-20;
			motor[right1] = a-20;
			motor[right2] = a-20;
			wait1Msec(500);
			motor[left1] = a-30;
			motor[left2] = a-30;
			motor[right1] = a-30;
			motor[right2] = a-30;
			wait1Msec(500);
			motor[left1] = 0;
			motor[left2] = 0;
			motor[right1] = 0;
			motor[right2] = 0;
}
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	nMotorEncoder[left1] = 0;
	nMotorEncoder[right1] = 0;
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
void
motorControllerInitialize( motor_controller *m, tMotor port )
{
	// bounds check port
	if( (port < port1) || (port > port10) )
		port = port1;

	// save motor port
	m->motor = port;

	// clear out variables
	m->e_count          = 0;
	m->e_count_last     = 0;
	m->e_timestamp      = 0;
	m->e_timestamp_last = 0;

	// Setup everything for current measurement
	m->i_free   = SMLIB_I_FREE_393;
	m->i_stall  = SMLIB_I_STALL_393;
	m->r_motor  = SMLIB_R_393;
	m->l_motor  = SMLIB_L_393;

	// Figure out what type of encoder we have
	m->encoder_id = getEncoderForMotor( port );
	if( m->encoder_id == 0 )
		return;

	// IME is attached
	// setup motor configuration specific constants
	switch( motorType[ m->motor ] )
	{
		// 393 set for high torque
	case    tmotorVex393_HBridge:
	case    tmotorVex393_MC29:
		m->ke_motor = SMLIB_Ke_393;
		m->rpm_free = SMLIB_RPM_FREE_393;

		if( m->encoder_id >= I2C_1 )
			m->ticks_per_rev = SMLIB_TPR_393Torque;
		else
			m->ticks_per_rev = SMLIB_TPR_393Quad;
		break;

		// 393 set for high speed
	case    tmotorVex393HighSpeed_HBridge:
	case    tmotorVex393HighSpeed_MC29:
		m->ke_motor = SMLIB_Ke_393/1.6;
		m->rpm_free = SMLIB_RPM_FREE_393 * 1.6;

		if( m->encoder_id >= I2C_1 )
			m->ticks_per_rev = SMLIB_TPR_393Speed;
		else
			m->ticks_per_rev = SMLIB_TPR_393Quad;
		break;

		// 393 set for Turbo
	case    tmotorVex393TurboSpeed_HBridge:
	case    tmotorVex393TurboSpeed_MC29:
		m->ke_motor = SMLIB_Ke_393/2.4;
		m->rpm_free = SMLIB_RPM_FREE_393 * 2.4;

		if( m->encoder_id >= I2C_1 )
			m->ticks_per_rev = SMLIB_TPR_393Turbo;
		else
			m->ticks_per_rev = SMLIB_TPR_393Quad;
		break;

	default:
		// Set unknown
		m->rpm_free      = 0;
		m->ticks_per_rev = SMLIB_TPR_393Quad;
		break;
	}

	// maximum theoretical v_bemf
	m->v_bemf_max = m->ke_motor * m->rpm_free;
}


float pid_Kp = 0.065;
float pid_Ki = 0.004;
float pid_Kd = 1.4;

float pid_Kp_right = 0.065;
float pid_Ki_right = 0.004;
float pid_Kd_right = 1.4;

static int pidRunning = 1;

float
calculateVelocity( motor_controller *m  )
{
	int     delta_ms;
	int     delta_enc;
	float   motor_velocity_t;

	// Must have an encoder
	if( m->encoder_id == (tSensors)(-1) )
		return(0);

	// First time is undefined
	// save last values and exit
	if( m->e_timestamp_last == 0 ) {
		// first read to get initial values
		getEncoderAndTimeStamp( m->motor, m->e_count_last, m->e_timestamp_last );
		// no calculation this time
		return(0.0);
	}

	// Get current encoder value
	getEncoderAndTimeStamp( m->motor, m->e_count, m->e_timestamp );

	// calculate the change in time since the last encoder poll
	delta_ms = m->e_timestamp - m->e_timestamp_last;
	m->e_timestamp_last = m->e_timestamp;

	// no change in time, then return result from last time
	// we don't want a divide by zero
	if(delta_ms == 0)
		return( m->v_current );

	// calculate the change in encoder count since the last poll
	delta_enc = (m->e_count - m->e_count_last);
	m->e_count_last = m->e_count;

	// Calculate velocity in rpm
	motor_velocity_t = (1000.0 / delta_ms) * delta_enc * 60.0 / m->ticks_per_rev;

	// filter if we are running quickly (< 100mS loop speed)
	if( delta_ms < 200 )
		m->v_current = (m->v_current * 0.8) + (motor_velocity_t * 0.2);
	else
		m->v_current = motor_velocity_t;

	// IIR filter means velocity will just keep getting smaller, clip if really low.
	if(fabs(m->v_current) < 0.01)
		m->v_current = 0;

	// return velocity
	return( m->v_current );
}

task pidController()
{
	float pidErrorL;
	float pidLastErrorL;
	float pidIntegralL;
	float pidDerivativeL;

	float pidErrorR;
	float pidLastErrorR;
	float pidIntegralR;
	float pidDerivativeR;

	pidLastErrorL = 0;
	pidIntegralL = 0;

	pidLastErrorR = 0;
	pidIntegralR = 0;

	while (true)
	{
		if(pidRunning)
		{

			targetSpeed = requestedShooterSpeed;
			pidErrorL = targetSpeed-flyVelocityL;

			if(pid_Ki!=0)
			{
				if(fabs(pidErrorL) < PID_INTEGRAL_LIMIT)
					pidIntegralL = pidIntegralL + pidErrorL;
				else
					pidIntegralL = 0;

			}
			else
				pidIntegralL = 0;
			if(pidErrorL !=0)
			{
				pidDerivativeL = pidErrorL - pidLastErrorL;
				pidLastErrorL = pidErrorL;
			}
			else
			{
				pidDerivativeL = 0;
			}
			if(pidErrorL < 2.0)
			{
				pidIntegralL = 0;
			}
			pidDriveL+= (pid_Kp*pidErrorL) + (pid_Ki*pidIntegralL) + (pid_Kd * pidDerivativeL);

			if(pidDriveL > PID_DRIVE_MAX)
				pidDriveL = PID_DRIVE_MAX;
			if(pidDriveL < PID_DRIVE_MIN)
				pidDriveL = PID_DRIVE_MIN;

			//right

			pidErrorR = targetSpeed-flyVelocityR;

			if(pid_Ki!=0)
			{
				if(fabs(pidErrorR) <PID_INTEGRAL_LIMIT)
					pidIntegralR = pidIntegralR + pidErrorR;
				else
					pidIntegralR = 0;

			}
			else
				pidIntegralR = 0;
			if(pidErrorR !=0)
			{
				pidDerivativeR = pidErrorR - pidLastErrorR;
				pidLastErrorR = pidErrorR;
			}
			else
			{
				pidDerivativeR = 0;
			}
			if(pidErrorR < 2.0)
			{
				pidIntegralR = 0;
			}
			pidDriveR+= (pid_Kp_right*pidErrorR) + (pid_Ki_right*pidIntegralR) + (pid_Kd_right * pidDerivativeR);

			if(pidDriveR > PID_DRIVE_MAX)
				pidDriveR = PID_DRIVE_MAX;
			if(pidDriveR < PID_DRIVE_MIN)
				pidDriveR = PID_DRIVE_MIN;

			flyVelocityL = calculateVelocity( &fwmL );
			flyVelocityR = calculateVelocity( &fwmR );
		}
		else
		{
			pidErrorL = 0;
			pidLastErrorL = 0;
			pidIntegralL = 0;
			pidDerivativeL = 0;
			pidErrorR = 0;
			pidLastErrorR = 0;
			pidIntegralR = 0;
			pidDerivativeR = 0;
		}
		wait1Msec(100);

	}
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................
	requestedShooterSpeed = 175;
	startTask(pidController);
	motorControllerInitialize( &fwmL, left1 );
	motorControllerInitialize( &fwmR, right1 );
			motor[left1] = a;
			motor[left2] = a;
			motor[right1] = a;
			motor[right2] = a;
			wait1Msec(1000);
			motor[left1] = b ;
			motor[left2] = b ;
			motor[right1] = b ;
			motor[right2] = b ;
	clearTimer(T2);
	while(time1[T2] < 3000)
	{
		motor[left1] = pidDriveL;
		motor[left2] = pidDriveL;
		motor[right1] = pidDriveR;
		motor[right2] = pidDriveR;
	}
		motor[intake] = 60;
		motor[up] = 70;
		motor[up2] = 70;
	while(true)
	{
		motor[left1] = pidDriveL;
		motor[left2] = pidDriveL;
		motor[right1] = pidDriveR;
		motor[right2] = pidDriveR;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	requestedShooterSpeed = 175;

	startTask(pidController);
	int intakeControl;
	int driveLeftControl;
	int driveRightControl;
	int upControl;
	int startShooterControl;

	int incUpCtrl;
	int incDownCtrl;
	int incUpCtrlSmall;
	int incDownCtrlSmall;
	motorControllerInitialize( &fwmL, left1 );
	motorControllerInitialize( &fwmR, right1 );


	while (true)
	{
		intakeControl = vexRT[Ch3];
		driveLeftControl = vexRT[Ch3Xmtr2] * driveTrainSpeedControl;
		driveRightControl = vexRT[Ch2Xmtr2] * driveTrainSpeedControl;
		upControl = vexRT[Ch2];
		startShooterControl = vexRT[Btn8D];

		incUpCtrl = vexRT[Btn5U];
		incDownCtrl = vexRT[Btn5D];

		incUpCtrlSmall = vexRT[Btn6U];
		incDownCtrlSmall = vexRT[Btn6D];

		if((incUpCtrl == 1) && (requestedShooterSpeed<200)&&(incUpLastPress == false))
		{
			incUpLastPress = true;
			requestedShooterSpeed += incValue;
			wait1Msec(200);
		}
		else if(incUpCtrl == 0)
		{
			incUpLastPress = false;
		}
		if((incDownCtrl == 1) && (requestedShooterSpeed>0)&&(incDownLastPress == false))
		{
			incDownLastPress = true;
			requestedShooterSpeed -= incValue;
			wait1Msec(200);
		}
		else if(incDownCtrl == 0)
		{
			incDownLastPress = false;
		}



		if((incUpCtrlSmall == 1) && (requestedShooterSpeed<200)&&(incUpLastPressSmall == false))
		{
			incUpLastPressSmall = true;
			requestedShooterSpeed += incValueSmall;
			wait1Msec(200);
		}
		else if(incUpCtrlSmall == 0)
		{
			incUpLastPressSmall = false;
		}
		if((incDownCtrlSmall == 1) && (requestedShooterSpeed>0)&&(incDownLastPressSmall == false))
		{
			incDownLastPressSmall = true;
			requestedShooterSpeed -= incValueSmall;
			wait1Msec(200);
		}
		else if(incDownCtrlSmall == 0)
		{
			incDownLastPressSmall = false;
		}




		if(requestedShooterSpeed > 200)
		{
			requestedShooterSpeed = 200;
		}
		if(requestedShooterSpeed < 0)
		{
			requestedShooterSpeed = 0;
		}

		if(vexRT[Btn7L] == 1)
		{
			updatePID = 1;
		}
		else if(vexRT[Btn7R] == 1)
		{
			updatePID = 0;
		}

		if(updatePID == 1)
		{
			motor[left1] = pidDriveL;
			motor[left2] = pidDriveL;
			motor[right1] = pidDriveR;
			motor[right2] = pidDriveR;
		}

		if(vexRT[Btn7DXmtr2] == 1)
		{
			driveTrainSpeedControl = 0.5;
		}
		else if(vexRT[Btn7UXmtr2] == 1)
		{
			driveTrainSpeedControl = 1;
		}

		if(abs(intakeControl) > deadzone)
		{
			motor[intake] = intakeControl;
		}
		else
		{
			motor[intake] = 0;
		}
		if(abs(driveLeftControl) > deadzone)
		{
			motor[driveLeft1] = driveLeftControl;
		}
		else
		{
			motor[driveLeft1] = 0;
		}
		if(abs(driveRightControl) > deadzone)
		{
			motor[driveRight1] = driveRightControl;
		}
		else
		{
			motor[driveRight1] = 0;
		}
		if(abs(upControl) > deadzone)
		{
			motor[up] = upControl;
			motor[up2] = upControl;
		}
		else
		{
			motor[up] = 0;
			motor[up2] = 0;
		}
		if(startShooterControl == 1)
		{
			motor[left1] = a;
			motor[left2] = a;
			motor[right1] = a;
			motor[right2] = a;
			wait1Msec(1000);
			motor[left1] = b ;
			motor[left2] = b ;
			motor[right1] = b ;
			motor[right2] = b ;
		}
		else if(vexRT[Btn8L] == 1)
		{
		slowDown();
		}
		if(vexRT[Btn8R] == 0)
		{
			// Displays Battery Levels to VEX Remote Screen
			powerExpanderBatteryV = SensorValue[in1]/.28;
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDPos(0,0);
			displayNextLCDString("Cortex Bat:");
			displayNextLCDNumber(nAvgBatteryLevel);
			displayLCDPos(1,0);
			displayNextLCDString("PowerE Bat:");
			displayNextLCDNumber(powerExpanderBatteryV);
		}
		else if(vexRT[Btn8R] == 1)
		{
			sonarValue = SensorValue[ultrasonic];
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDPos(0,0);
			displayNextLCDString("Ultrasonic:");
			displayNextLCDNumber(sonarValue);
			displayLCDPos(1,0);
			displayNextLCDString("Exp. Bat");
			displayNextLCDNumber(powerExpanderBatteryV);
		}
		datalogDataGroupStart();
		datalogAddValue( 0, flyVelocityL );
		datalogAddValue( 1, flyVelocityR );
		datalogAddValue( 2, pidDriveL );
		datalogAddValue( 3, pidDriveR );
		datalogDataGroupEnd();
		wait1Msec(25);
	}
}
