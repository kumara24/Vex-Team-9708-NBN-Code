#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerE,         sensorAnalog)
#pragma config(Sensor, dgtl1,  quadLeft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  quadRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl10, ledRed,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, ledGreen,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, ledYellow,      sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           up,            tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           driveLeft1,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           left1,         tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port4,           left2,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           right1,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port7,           right2,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           driveRight1,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port10,          up2,           tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)


#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#define PID_DRIVE_MAX 110
#define PID_DRIVE_MIN 0

#define PID_INTEGRAL_LIMIT 40
#define incValue 10
#define incValueSmall 5
#define SMLIBq_TPR_393Turbo 261.333
#define SMLIB_TPR_393Speed 392.0
#define SMLIB_TPR_393Torque 627.2
#define SMLIB_TPR_393Quad 360.0
#define PID_VEL_MAX 700
#define deadzone 20

float driveTrainSpeedControl = 1.0;
float powerExpanderBatteryV = 2;

float flyVelocityL;
float flyVelocityR;
int flyStartup = 1;

float pidDriveL, pidDriveR;
int incUpLastPress = 0;
int incDownLastPress = 0;
int incUpLastPressSmall = 0;
int incDownLastPressSmall = 0;
int requestedShooterSpeed = 0;

int startspeed=40;

float pid_Kp = 0.05;
float pid_Ki = 0.0;
float pid_Kd = 0.4;

float pid_Kp_right = 0.05;
float pid_Ki_right = 0.0;
float pid_Kd_right = 0.41;

long timeSinceLastRun = 1;
int deltaTicksRight;
int lastRunTicksRight;
int thisRunTicksRight;
int deltaTicksLeft;
int lastRunTicksLeft;
int thisRunTicksLeft;
int updatePID;

float pid_Kp_selected = 0.021;
float pid_Ki_selected = 0.0;
float	pid_Kd_selected = 0.844;

float	pid_Kp_selectedR = 0.021;
float pid_Ki_selectedR = 0.0;
float pid_Kd_selectedR = 0.844;

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	nMotorEncoder[left1] = 0;
	nMotorEncoder[right1] = 0;
	nMotorEncoder[driveLeft1] = 0;
	nMotorEncoder[driveRight1] = 0;
	SensorValue[quadLeft] = 0;
	SensorValue[quadRight] = 0;
	clearTimer(T1);
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
void calculateSpeed()
{
	//Velocity reading
	int flywheelRightEncoder = -1 * SensorValue[quadRight];
	int flywheelLeftEncoder =SensorValue[quadLeft];

	lastRunTicksRight = thisRunTicksRight;
	thisRunTicksRight = flywheelRightEncoder;
	deltaTicksRight = thisRunTicksRight - lastRunTicksRight;

	lastRunTicksLeft = thisRunTicksLeft;
	thisRunTicksLeft = flywheelLeftEncoder;
	deltaTicksLeft = thisRunTicksLeft - lastRunTicksLeft;

	timeSinceLastRun = time10[T1];
	if (timeSinceLastRun) {
	flyVelocityL =  (deltaTicksLeft * 50)/(timeSinceLastRun * 3);
	flyVelocityR =  (deltaTicksRight* 50)/(timeSinceLastRun * 3);
	}
	//	lastSysTime = nSysTime;
	clearTimer(T1);
}

void pidSelect()
{
	pid_Kp = pid_Kp_selected;
	pid_Ki = pid_Ki_selected;
	pid_Kd = pid_Kd_selected;

	pid_Kp_right = pid_Kp_selectedR;
	pid_Ki_right = pid_Ki_selectedR;
	pid_Kd_right = pid_Kd_selectedR;
}

task music() {
	while(1) {
		if(flyVelocityL > 200 && updatePID ==1){
			clearSounds();
			playImmediateTone(flyVelocityL + 150, 50);
		}
		wait1Msec(30);
	}
}

task pidController()
{
	startTask(music, 4);
	float pidErrorL;
	float pidLastErrorL;
	float pidIntegralL;
	float pidDerivativeL;

	float pidErrorR;
	float pidLastErrorR;
	float pidIntegralR;
	float pidDerivativeR;

	pidLastErrorL = 0;
	pidIntegralL = 0;

	pidLastErrorR = 0;
	pidIntegralR = 0;

	while (true)
	{
		if(flyStartup == 1 && (flyVelocityR>requestedShooterSpeed))
			flyStartup = 0;
		else if(flyStartup==0)
			pidSelect();

		pidErrorL = requestedShooterSpeed-flyVelocityL;

		if(pid_Ki!=0)
		{
			if(fabs(pidErrorL) < PID_INTEGRAL_LIMIT)
				pidIntegralL = pidIntegralL + pidErrorL;
			else
				pidIntegralL = 0;

		}
		else
			pidIntegralL = 0;
		if(pidErrorL !=0)
		{
			pidDerivativeL = pidErrorL - pidLastErrorL;
			pidLastErrorL = pidErrorL;
		}
		else
		{
			pidDerivativeL = 0;
		}
		if(pidErrorL < 4.0)
		{
			pidIntegralL = 0;
		}
		pidDriveL+= (pid_Kp*pidErrorL) + (pid_Ki*pidIntegralL) + (pid_Kd * pidDerivativeL);

		if(pidDriveL > PID_DRIVE_MAX)
			pidDriveL = PID_DRIVE_MAX;
		if(pidDriveL < PID_DRIVE_MIN)
			pidDriveL = PID_DRIVE_MIN;

		//right

		pidErrorR = requestedShooterSpeed-flyVelocityR;

		if(pid_Ki!=0)
		{
			if(fabs(pidErrorR) <PID_INTEGRAL_LIMIT)
				pidIntegralR = pidIntegralR + pidErrorR;
			else
				pidIntegralR = 0;

		}
		else
			pidIntegralR = 0;
		if(pidErrorR !=0)
		{
			pidDerivativeR = pidErrorR - pidLastErrorR;
			pidLastErrorR = pidErrorR;
		}
		else
		{
			pidDerivativeR = 0;
		}
		if(pidErrorR < 4.0)
		{
			pidIntegralR = 0;
		}
		pidDriveR+= (pid_Kp_right*pidErrorR) + (pid_Ki_right*pidIntegralR) + (pid_Kd_right * pidDerivativeR);

		if(pidDriveR > PID_DRIVE_MAX)
			pidDriveR = PID_DRIVE_MAX;
		if(pidDriveR < PID_DRIVE_MIN)
			pidDriveR = PID_DRIVE_MIN;

		calculateSpeed();

		//LEDs
		if(pidErrorR < 5)
			SensorValue(ledGreen) = 1;
		else
			SensorValue(ledGreen) = 0;

		if(pidErrorR < 15)
			SensorValue(ledYellow) = 1;
		else
			SensorValue(ledYellow) = 0;

		if(pidErrorR > 30)
			SensorValue(ledRed) = 1;
		else
			SensorValue(ledRed) = 0;

		wait1Msec(100);

	}
	//pidErrorL = 0;
	//pidLastErrorL = 0;
	//pidIntegralL = 0;
	//pidDerivativeL = 0;
	//pidErrorR = 0;
	//pidLastErrorR = 0;
	//pidIntegralR = 0;
	//pidDerivativeR = 0;
}

void clearEncoders() {
	nMotorEncoder[driveLeft1] = 0;
	nMotorEncoder[driveRight1] = 0;
}

void drive(int encoderCounts, int speed)
{
	clearEncoders();
	//While both of the encoders are less than the specified amount
	while(abs(nMotorEncoder[driveRight1]) < abs(encoderCounts))
	{
		//If the two encoder values are equal
		if(abs(nMotorEncoder[driveRight1]) == abs(nMotorEncoder[driveLeft1]))
		{
			//Move the robot forward at the specified speed
			motor[driveRight1] = speed;
			motor[driveLeft1] = speed;

		}
		if(abs(nMotorEncoder[driveRight1]) < abs(nMotorEncoder[driveLeft1]))
		{
			//Move the robot forward at the specified speed
			motor[driveRight1] = speed;
			motor[driveLeft1] = speed+10;

		}
		else if(abs(nMotorEncoder[driveRight1]) > abs(nMotorEncoder[driveLeft1]))
		{
			//Move the robot forward at the specified speed
			motor[driveRight1] = speed+10;
			motor[driveLeft1] = speed;

		}
	}
	//Stop the robot
	motor[driveRight1] = 0;
	motor[driveLeft1] = 0;
}



//Turn the robot left for the specified encoder counts
//at a specified speed
void turnLeft(int encoderCounts, int speed)
{
	//Clear the encoders before using them
	clearEncoders();
	//While the absolute value of the right motor's encoder is less
	//than the specified amount
	while(abs(nMotorEncoder[driveLeft1]) < encoderCounts)
	{
		//If the two encoder values are equal
		if(abs(nMotorEncoder[driveLeft1]) == abs(nMotorEncoder[driveLeft1]))
		{
			//Move the robot forward at the specified speed
			motor[driveRight1] = speed;
			motor[driveLeft1] = -speed;

		}
		if(abs(nMotorEncoder[driveLeft1]) < abs(nMotorEncoder[driveLeft1]))
		{
			//Move the robot forward at the specified speed
			motor[driveRight1] = speed;
			motor[driveLeft1] = -(speed+10);

		}
		else if(abs(nMotorEncoder[driveLeft1]) > abs(nMotorEncoder[driveLeft1]))
		{
			//Move the robot forward at the specified speed
			motor[driveRight1] = speed+10;
			motor[driveLeft1] = -speed;

		}
	}
	//Stop the robot
	motor[driveRight1] = 0;
	motor[driveLeft1] = 0;
}

//Turn the robot left for the specified encoder counts
//at a specified speed
void turnRight(int encoderCounts, int speed)
{

	//Clear the encoders
	clearEncoders();

	//While the absolute value of the left motor's encoder is less
	//than the specified amount

	//Turn the robot to the right at the specified speed
	while(abs(nMotorEncoder[driveRight1]) < encoderCounts)
	{
		//If the two encoder values are equal
		if(abs(nMotorEncoder[driveRight1]) == abs(nMotorEncoder[driveLeft1]))
		{
			//Move the robot forward at the specified speed
			motor[driveRight1] = -speed;
			motor[driveLeft1] = speed;

		}
		if(abs(nMotorEncoder[driveRight1]) < abs(nMotorEncoder[driveLeft1]))
		{
			//Move the robot forward at the specified speed
			motor[driveRight1] = -speed;
			motor[driveLeft1] = speed+10;

		}
		else if(abs(nMotorEncoder[driveRight1]) > abs(nMotorEncoder[driveLeft1]))
		{
			//Move the robot forward at the specified speed
			motor[driveRight1] = -(speed+10);
			motor[driveLeft1] = speed;

		}
	}
	//Stop the robot
	motor[driveRight1] = 0;
	motor[driveLeft1] = 0;
}


void slowDown()
{
	updatePID = 0;
	stopTask(pidController);
	stopTask(music);
	for(int i = 49; i >= 0; i-= 2)
	{
		motor[left1] = i;
		motor[left2] = i;
		motor[right1] = i;
		motor[right2] = i;
		wait1Msec(50);
	}
	motor[left1] = 0;
	motor[left2] = 0;
	motor[right1] = 0;
	motor[right2] = 0;
}

void startup()
{
	updatePID = 0;
	stopTask(pidController);
	for(int i = 0; i <= startspeed; i+= 2)
	{
		motor[left1] = i;
		motor[left2] = i;
		motor[right1] = i;
		motor[right2] = i;
		wait1Msec(50);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

void driverLoads(int rSS) {
	requestedShooterSpeed = rSS;
	flyStartup = 1;
	pid_Kp = 0.05;
	pid_Ki = 0.0;
	pid_Kd = 0.4;

	pid_Kp_right = 0.05;
	pid_Ki_right = 0.0;
	pid_Kd_right = 0.41;
	flyVelocityL = 0;
	flyVelocityR = 0;
	updatePID = 1;
	bPlaySounds = true;
	startTask(pidController);
	requestedShooterSpeed = rSS;
	pid_Kp_selected = 0.0235;
	pid_Ki_selected = 0.0;
	pid_Kd_selected = 0.758;

	pid_Kp_selectedR = 0.02;
	pid_Ki_selectedR = 0.0;
	pid_Kd_selectedR = 0.857;
	clearTimer(T2);
	while(time1[T2] < 1500)
	{
		motor[left1] = pidDriveL;
		motor[left2] = pidDriveL;
		motor[right1] = pidDriveR;
		motor[right2] = pidDriveR;
	}
	motor[intake] = 110;
	motor[up] = 85;
	motor[up2] = 85;
	clearTimer(T2);
	while(time1[T2] < 4500)
	{
		motor[left1] = pidDriveL;
		motor[left2] = pidDriveL;
		motor[right1] = pidDriveR;
		motor[right2] = pidDriveR;
	}
	stopTask(pidController);
	slowDown();
}
task autonomous()
{
	driverLoads(440);
	drive(1500, 70);
	turnLeft(550, 70);
	drive(500, 70);
	motor[up] = 100;
	motor[up2] = 100;
	wait1Msec(1000);
	drive(500, 70);
	/*
	wait1Msec(1000);
	drive(500, -70);
	wait1Msec(1000);
	drive(500, 70);
	*/
	wait1Msec(1000);
	drive(1000, -70);
	turnRight(490, 70);
	wait1Msec(500);
	driverLoads(380);
	motor[up] = 0;
	motor[up2] = 0;
}

task usercontrol()
{
	requestedShooterSpeed = 440;
	int intakeControl;
	int driveLeftControl;
	int driveRightControl;
	int upControl;
	int startShooterControl;

	int incUpCtrl;
	int incDownCtrl;
	int incUpCtrlSmall;
	int incDownCtrlSmall;
	int divideByZero = 0;

	while (true)	{
		if(updatePID == 0) {
			bPlaySounds = false;
		}
		intakeControl = vexRT[Ch3];
		driveLeftControl = vexRT[Ch3Xmtr2] * driveTrainSpeedControl;
		driveRightControl = vexRT[Ch2Xmtr2] * driveTrainSpeedControl;
		upControl = vexRT[Ch2];
		startShooterControl = vexRT[Btn8D];

		incUpCtrl = vexRT[Btn5U];
		incDownCtrl = vexRT[Btn5D];

		incUpCtrlSmall = vexRT[Btn6U];
		incDownCtrlSmall = vexRT[Btn6D];

		if((incUpCtrl == 1) && (requestedShooterSpeed<PID_VEL_MAX)&&(incUpLastPress == false))
		{
			incUpLastPress = true;
			requestedShooterSpeed += incValue;
			wait1Msec(200);
		}
		else if(incUpCtrl == 0)
		{
			incUpLastPress = false;
		}
		if((incDownCtrl == 1) && (requestedShooterSpeed>0)&&(incDownLastPress == false))
		{
			incDownLastPress = true;
			requestedShooterSpeed -= incValue;
			wait1Msec(200);
		}
		else if(incDownCtrl == 0)
		{
			incDownLastPress = false;
		}



		if((incUpCtrlSmall == 1) && (requestedShooterSpeed<PID_VEL_MAX)&&(incUpLastPressSmall == false))
		{
			incUpLastPressSmall = true;
			requestedShooterSpeed += incValueSmall;
			wait1Msec(200);
		}
		else if(incUpCtrlSmall == 0)
		{
			incUpLastPressSmall = false;
		}
		if((incDownCtrlSmall == 1) && (requestedShooterSpeed>0)&&(incDownLastPressSmall == false))
		{
			incDownLastPressSmall = true;
			requestedShooterSpeed -= incValueSmall;
			wait1Msec(200);
		}
		else if(incDownCtrlSmall == 0)
		{
			incDownLastPressSmall = false;
		}




		if(requestedShooterSpeed > PID_VEL_MAX)
		{
			requestedShooterSpeed = PID_VEL_MAX;
		}
		if(requestedShooterSpeed < 0)
		{
			requestedShooterSpeed = 0;
		}

		if(vexRT[Btn7U] == 1)
		{
			requestedShooterSpeed = 440;
			pid_Kp_selected = 0.0235;
			pid_Ki_selected = 0.0;
			pid_Kd_selected = 0.758;

			pid_Kp_selectedR = 0.02;
			pid_Ki_selectedR = 0.0;
			pid_Kd_selectedR = 0.857;
		}

		if(vexRT[Btn7D] == 1)
		{
			requestedShooterSpeed = 380;
			pid_Kp_selected = 0.023;
			pid_Ki_selected = 0.0;
			pid_Kd_selected = 0.9;

			pid_Kp_selectedR = 0.02;
			pid_Ki_selectedR = 0.0;
			pid_Kd_selectedR = 0.9;
		}

		if(vexRT[Btn8R] == 1)
		{
			requestedShooterSpeed=380;
			pid_Kp_selected = 0.028;
			pid_Ki_selected = 0.0;
			pid_Kd_selected = 1;

			pid_Kp_selectedR = 0.025;
			pid_Ki_selectedR = 0.0;
			pid_Kd_selectedR = 1;
		}
		if(vexRT[Btn7L] == 1 && divideByZero == 0)
		{
			divideByZero = 1;
			flyStartup = 1;
			pid_Kp = 0.05;
			pid_Ki = 0.0;
			pid_Kd = 0.4;

			pid_Kp_right = 0.05;
			pid_Ki_right = 0.0;
			pid_Kd_right = 0.41;
			flyVelocityL = 0;
			flyVelocityR = 0;
			updatePID = 1;
			bPlaySounds = true;
			startTask(pidController);

		}

		if(updatePID == 1)

		{
			motor[left1] = pidDriveL;
			motor[left2] = pidDriveL;
			motor[right1] = pidDriveR;
			motor[right2] = pidDriveR;
		}

		if(vexRT[Btn7DXmtr2] == 1)
		{
			driveTrainSpeedControl = 0.3;
		}
		else if(vexRT[Btn7UXmtr2] == 1)
		{
			driveTrainSpeedControl = 1;
		}
		if(abs(intakeControl) > deadzone)
		{
			motor[intake] = intakeControl;
			motor[up2] = intakeControl;
		}
		else
		{
			motor[intake] = 0;
			motor[up2] = 0;
		}
		if(abs(driveLeftControl) > deadzone)
		{
			motor[driveLeft1] = driveLeftControl;
		}
		else
		{
			motor[driveLeft1] = 0;
		}
		if(abs(driveRightControl) > deadzone)
		{
			motor[driveRight1] = driveRightControl;
		}
		else
		{
			motor[driveRight1] = 0;
		}
		if(abs(upControl) > deadzone)
		{
			motor[up] = upControl;
		}
		else
		{
			motor[up] = 0;
		}
		if(startShooterControl == 1)
		{
			startup();
			divideByZero = 0;
		}
		else if(vexRT[Btn8L] == 1)
		{
			slowDown();
			divideByZero = 0;
		}

		// Displays Battery Levels to VEX Remote Screen
		powerExpanderBatteryV = SensorValue[in1]/.28;
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDPos(0,0);
		displayNextLCDString("Cortex Bat:");
		displayNextLCDNumber(nAvgBatteryLevel);
		displayLCDPos(1,0);
		displayNextLCDString("PowerE Bat:");
		displayNextLCDNumber(powerExpanderBatteryV);

		datalogDataGroupStart();
		datalogAddValue( 0, flyVelocityL );
		datalogAddValue( 1, flyVelocityR );
		datalogAddValue(2, pidDriveL);
		datalogAddValue(3, pidDriveR);
		datalogAddValue(4, timeSinceLastRun);
		datalogDataGroupEnd();
		wait1Msec(50);
	}
}
